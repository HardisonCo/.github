# Chapter 7: Local Python Executor

In the previous chapter, [Agent Types](06_agent_types.md), we learned how agents can handle different kinds of data. Now, let's explore how an agent can execute Python code directly. This is like giving our chef agent the ability to create their own tools on the fly! This powerful capability is provided by the **Local Python Executor**.

Imagine our chef agent needs to convert ounces to grams.  They could use a pre-built conversion tool, but what if they need a specific rounding behavior? The Local Python Executor allows the agent to write a small Python snippet to perform this conversion with custom rounding.  It's like giving the chef a mini coding lab right in their kitchen!

## What is the Local Python Executor?

The Local Python Executor is a safe environment where the agent can execute Python code. It's like a sandboxed playground where the agent can experiment without breaking anything. It prevents the agent from performing harmful actions, like deleting files or accessing sensitive information.  It's like ensuring our chef agent doesn't accidentally set off the fire alarm while experimenting with a new flambÃ© technique.

## Using the Local Python Executor

Let's see how to use the Local Python Executor to convert ounces to grams with custom rounding.

```python
from smolagents import LocalPythonExecutor

executor = LocalPythonExecutor(additional_authorized_imports=[])

# Python code to execute
code = """
ounces = 10
grams = ounces * 28.35
rounded_grams = round(grams, 1)
final_answer(rounded_grams)
"""

# Execute the code
result, logs, is_final_answer = executor(code)

print(f"Result: {result}") # Output: Result: 283.5
print(f"Logs: {logs}") # Output: Logs: 
print(f"Is final answer: {is_final_answer}") # Output: Is final answer: True
```

This code creates a `LocalPythonExecutor`. It then defines a Python snippet that converts ounces to grams and rounds the result to one decimal place. The `final_answer()` function signals that the result is the final answer for the agent's current step. The executor runs the code, and the result, logs (print outputs), and a flag indicating if it's a final answer are returned.

## Inside the Local Python Executor

Here's a simplified sequence diagram showing how the Local Python Executor works:

```mermaid
sequenceDiagram
    participant Agent
    participant Local Python Executor

    Agent->>Local Python Executor: ounces = 10; grams = ounces * 28.35; final_answer(grams)
    activate Local Python Executor
    Local Python Executor-->>Agent: 283.5 (Result, Logs, Is Final Answer)
    deactivate Local Python Executor
```

1. The [Agent](01_agent.md) sends Python code to the Local Python Executor.
2. The executor evaluates the code in a safe environment.
3. The executor returns the result, logs, and a final answer flag to the agent.

The `evaluate_python_code` function in the `local_python_executor.py` file handles the core logic of code execution.

```python
# Simplified code from local_python_executor.py
def evaluate_python_code(code, static_tools, custom_tools, state, authorized_imports):
    # ... (Parse the code into an Abstract Syntax Tree)
    try:
        # ... (Evaluate the AST, handling variables, function calls, etc.)
        return result, is_final_answer # Return the result and final answer flag
    except Exception as e:
        # ... (Handle errors)
```

The `evaluate_ast` function recursively evaluates the Abstract Syntax Tree (AST) of the code, handling variables, function calls, and other Python constructs.

```python
# Simplified code from local_python_executor.py
def evaluate_ast(expression, state, static_tools, custom_tools, authorized_imports):
    if isinstance(expression, ast.Assign):
        # ... (Handle variable assignment)
    elif isinstance(expression, ast.Call):
        # ... (Handle function calls)
    # ... (Handle other AST node types)
```

## Conclusion

In this chapter, we learned about the `Local Python Executor` and how it provides a safe environment for agents to execute Python code. We saw how to use the executor to perform calculations and explored its internal implementation. Next, we'll learn about [Remote Executors](08_remote_executors.md) and how they enable code execution in different environments.


---

Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge)