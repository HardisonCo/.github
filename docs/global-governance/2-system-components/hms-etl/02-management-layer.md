# Chapter 2: Management Layer

Welcome to **Chapter 2**, where we explore the **Management Layer**—the operational heart of HMS-ETL. In [Chapter 1: Governance Layer](01_governance_layer_.md), we set the rules. Now, we’ll see how day-to-day work gets done: orchestrating ETL pipelines, scheduling tasks, and tracking progress—just like a federal program management office assigning cases and resources.

---

## 1. Why a Management Layer?

Imagine the U.S. Botanic Garden receives new plant accession requests from different labs. Each request needs multiple steps:

1. Validate the plant data  
2. Enrich with botanical metadata  
3. Store in the central repository  
4. Notify researchers  

The **Management Layer** is like the executive office that:

- Receives new “cases” (plant requests)  
- Decides which microservice handles each step  
- Tracks status and retries failures  

Without it, each service would operate in isolation, making coordination a nightmare.

---

## 2. Key Concepts

1. **Workflow Coordinator**  
   Defines a sequence of tasks (steps) to process one case.  
2. **Task Queue**  
   Holds pending tasks and dispatches them to microservices.  
3. **Service Orchestrator**  
   Calls the right service (e.g., enrichment, storage) for each step.  
4. **Status Tracker**  
   Monitors progress, logs events, and retries on errors.

---

## 3. Using the Management Layer

### 3.1 Define a Simple Workflow

Here’s a minimal Python example that registers and runs a “plant accession” workflow:

```python
from hms_etl.management import ManagementLayer

# 1. Create manager
mgr = ManagementLayer()

# 2. Define workflow steps
steps = ["validate", "enrich", "store", "notify"]
mgr.register_workflow("plant_accession", steps)

# 3. Execute for one record
record = {"id": 42, "species": "rosa alba"}
result = mgr.execute("plant_accession", record)

print(result)
# -> {"status":"completed","case_id":42}
```

*Explanation:*  
1. We create a `ManagementLayer`.  
2. We register a workflow named `"plant_accession"`.  
3. We call `execute()`, which runs each step in order and returns a final status.

---

## 4. What Happens Under the Hood?

Here’s a simple sequence of calls for `execute()`:

```mermaid
sequenceDiagram
  participant Citizen
  participant Manager as ManagementLayer
  participant Queue as Task Queue
  participant Service as Service Orchestrator
  participant Audit as Status Tracker

  Citizen->>Manager: execute("plant_accession", record)
  Manager->>Queue: enqueue(task1)
  Queue->>Service: dispatch("validate", record)
  Service->>Audit: log("validated")
  ... repeat for enrich, store, notify ...
  Manager->>Audit: log("completed")
  Manager->>Citizen: return result
```

1. **enqueue**: Each step becomes a queue message.  
2. **dispatch**: Orchestrator calls the actual microservice.  
3. **log**: Tracker records success or failure.  
4. **return**: After all steps, we send back the outcome.

---

## 5. Inside the Code

### 5.1 File: `hms_etl/management.py`

```python
class ManagementLayer:
    def __init__(self):
        self.workflows = {}          # Stores step lists

    def register_workflow(self, name, steps):
        self.workflows[name] = steps

    def execute(self, name, record):
        for step in self.workflows[name]:
            self._run_step(step, record)
        return {"status": "completed", "case_id": record["id"]}
```

*Explanation:*  
- `workflows` maps names to step arrays.  
- `execute` loops steps and calls `_run_step`.

### 5.2 Dispatching a Step

```python
    def _run_step(self, step, record):
        # Simplified: directly call a service function
        from hms_etl.services import orchestrator
        success = orchestrator.call(step, record)
        self._log(step, record, success)

    def _log(self, step, record, success):
        print(f"AUDIT: step={step}, case={record['id']}, ok={success}")
```

*Explanation:*  
- `_run_step` uses a central orchestrator.  
- `_log` prints out an audit line. In real life, this goes to a database or dashboard.

---

## 6. Conclusion

You’ve learned how the **Management Layer**:

- Defines and registers ETL workflows.  
- Uses a task queue and orchestrator to run each step.  
- Tracks progress and logs events.

Next, we’ll see how HMS-ETL stays in sync with outside systems in [Chapter 3: External System Synchronization](03_external_system_synchronization_.md).

---

Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge)