# HMS Agent Lifecycle Management FFI Bindings Specification

This document specifies the Foreign Function Interface (FFI) bindings for the HMS Agent Lifecycle Management system, enabling cross-language management of agent lifecycle states and transitions.

## 1. Overview

Agent Lifecycle Management is a critical component that ensures proper state transitions, event notifications, and resource management throughout an agent's existence. The FFI bindings enable control and monitoring of agent lifecycles from any supported language.

## 2. Core Concepts

### 2.1 Lifecycle States

```protobuf
syntax = "proto3";

package hms.agent.lifecycle.v1;

// State of an agent in its lifecycle
enum LifecycleState {
  // Unknown state
  STATE_UNSPECIFIED = 0;
  
  // Agent is initialized but not yet active
  INITIALIZED = 1;
  
  // Agent is active and processing tasks
  ACTIVE = 2;
  
  // Agent is paused (will resume from current state)
  PAUSED = 3;
  
  // Agent is suspended (may need recovery to resume)
  SUSPENDED = 4;
  
  // Agent is shutting down
  SHUTTING_DOWN = 5;
  
  // Agent is terminated
  TERMINATED = 6;
  
  // Agent is in maintenance mode
  MAINTENANCE = 7;
  
  // Agent is in error state
  ERROR = 8;
  
  // Agent is upgrading
  UPGRADING = 9;
  
  // Agent is recovering from error or suspension
  RECOVERING = 10;
}

// Type of lifecycle transition event
enum TransitionType {
  // Unknown transition
  TRANSITION_UNSPECIFIED = 0;
  
  // Normal state transition
  NORMAL = 1;
  
  // Forced state transition
  FORCED = 2;
  
  // Automatic state transition
  AUTOMATIC = 3;
  
  // Error-triggered state transition
  ERROR_TRIGGERED = 4;
  
  // Maintenance-related state transition
  MAINTENANCE = 5;
}
```

### 2.2 Lifecycle Events

```protobuf
syntax = "proto3";

package hms.agent.lifecycle.v1;

import "google/protobuf/timestamp.proto";
import "lifecycle_state.proto";

// Event generated during an agent's lifecycle
message LifecycleEvent {
  // Unique event ID
  string event_id = 1;
  
  // Agent ID
  string agent_id = 2;
  
  // Previous state
  LifecycleState previous_state = 3;
  
  // New state
  LifecycleState new_state = 4;
  
  // Transition type
  TransitionType transition_type = 5;
  
  // Timestamp when the event occurred
  google.protobuf.Timestamp timestamp = 6;
  
  // User or system that initiated the transition
  string initiated_by = 7;
  
  // Reason for the transition
  string reason = 8;
  
  // Additional event data
  map<string, string> metadata = 9;
}

// Request to transition an agent to a new state
message TransitionRequest {
  // Agent ID
  string agent_id = 1;
  
  // Target state
  LifecycleState target_state = 2;
  
  // Force transition even if not normally allowed
  bool force = 3;
  
  // Reason for the transition
  string reason = 4;
  
  // Timeout in milliseconds (0 = use default)
  int32 timeout_ms = 5;
  
  // Additional request data
  map<string, string> metadata = 6;
}

// Response to a transition request
message TransitionResponse {
  // Whether the transition was successful
  bool success = 1;
  
  // Previous state
  LifecycleState previous_state = 2;
  
  // Current state after transition attempt
  LifecycleState current_state = 3;
  
  // Event generated by the transition
  LifecycleEvent event = 4;
  
  // Error message if transition failed
  string error_message = 5;
}
```

### 2.3 Lifecycle Management

```protobuf
syntax = "proto3";

package hms.agent.lifecycle.v1;

import "lifecycle_state.proto";
import "lifecycle_event.proto";

// Service for managing agent lifecycles
service LifecycleManager {
  // Get the current state of an agent
  rpc GetState(GetStateRequest) returns (GetStateResponse);
  
  // Transition an agent to a new state
  rpc TransitionState(TransitionRequest) returns (TransitionResponse);
  
  // Get the transition history for an agent
  rpc GetTransitionHistory(GetHistoryRequest) returns (GetHistoryResponse);
  
  // Watch for lifecycle events
  rpc WatchEvents(WatchEventsRequest) returns (stream LifecycleEvent);
  
  // Register a lifecycle hook
  rpc RegisterHook(RegisterHookRequest) returns (RegisterHookResponse);
}

// Request to get an agent's current state
message GetStateRequest {
  // Agent ID
  string agent_id = 1;
  
  // Whether to include detailed state info
  bool include_details = 2;
}

// Response with agent state information
message GetStateResponse {
  // Current lifecycle state
  LifecycleState state = 1;
  
  // Time spent in current state
  int64 time_in_state_ms = 2;
  
  // Previous state
  LifecycleState previous_state = 3;
  
  // State metadata
  map<string, string> metadata = 4;
  
  // Whether the agent is in a transitioning state
  bool is_transitioning = 5;
  
  // Last transition timestamp
  google.protobuf.Timestamp last_transition = 6;
  
  // Error information if in error state
  ErrorInfo error_info = 7;
}

// Error information for agents in error state
message ErrorInfo {
  // Error code
  int32 code = 1;
  
  // Error message
  string message = 2;
  
  // Error timestamp
  google.protobuf.Timestamp timestamp = 3;
  
  // Whether the error is recoverable
  bool is_recoverable = 4;
  
  // Recovery actions that can be taken
  repeated string recovery_actions = 5;
}

// Request to get transition history
message GetHistoryRequest {
  // Agent ID
  string agent_id = 1;
  
  // Maximum number of events to return
  int32 limit = 2;
  
  // Filter by transition type
  TransitionType transition_type = 3;
  
  // Start time for history query
  google.protobuf.Timestamp start_time = 4;
  
  // End time for history query
  google.protobuf.Timestamp end_time = 5;
}

// Response with transition history
message GetHistoryResponse {
  // Lifecycle events in chronological order
  repeated LifecycleEvent events = 1;
  
  // Token for pagination
  string next_page_token = 2;
}

// Request to watch for lifecycle events
message WatchEventsRequest {
  // Agent ID to watch (empty for all agents)
  string agent_id = 1;
  
  // States to watch for
  repeated LifecycleState states = 2;
  
  // Transition types to watch for
  repeated TransitionType transition_types = 3;
}

// Request to register a lifecycle hook
message RegisterHookRequest {
  // Hook name
  string hook_name = 1;
  
  // States that trigger this hook
  repeated LifecycleState trigger_states = 2;
  
  // Transition types that trigger this hook
  repeated TransitionType trigger_transitions = 3;
  
  // Whether hook should block transition until completed
  bool is_blocking = 4;
  
  // Timeout for hook execution in milliseconds
  int32 timeout_ms = 5;
  
  // Hook configuration
  map<string, string> config = 6;
  
  // Agent IDs this hook applies to (empty for all agents)
  repeated string agent_ids = 7;
}

// Response to hook registration
message RegisterHookResponse {
  // Whether registration was successful
  bool success = 1;
  
  // Generated hook ID
  string hook_id = 2;
  
  // Error message if registration failed
  string error_message = 3;
}
```

## 3. Language-Specific Bindings

### 3.1 Rust API

```rust
// Lifecycle state enum
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum LifecycleState {
    Unspecified,
    Initialized,
    Active,
    Paused,
    Suspended,
    ShuttingDown,
    Terminated,
    Maintenance,
    Error,
    Upgrading,
    Recovering,
}

// Transition type enum
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TransitionType {
    Unspecified,
    Normal,
    Forced,
    Automatic,
    ErrorTriggered,
    Maintenance,
}

// Lifecycle event
#[derive(Debug, Clone)]
pub struct LifecycleEvent {
    pub event_id: String,
    pub agent_id: String,
    pub previous_state: LifecycleState,
    pub new_state: LifecycleState,
    pub transition_type: TransitionType,
    pub timestamp: DateTime<Utc>,
    pub initiated_by: String,
    pub reason: String,
    pub metadata: HashMap<String, String>,
}

// Lifecycle manager client
pub trait LifecycleManager {
    // Get the current state of an agent
    fn get_state(&self, agent_id: &str, include_details: bool) -> Result<GetStateResponse, Error>;
    
    // Transition an agent to a new state
    fn transition_state(&self, request: TransitionRequest) -> Result<TransitionResponse, Error>;
    
    // Get the transition history for an agent
    fn get_transition_history(&self, request: GetHistoryRequest) -> Result<GetHistoryResponse, Error>;
    
    // Watch for lifecycle events
    fn watch_events(&self, request: WatchEventsRequest) -> Result<EventStream, Error>;
    
    // Register a lifecycle hook
    fn register_hook(&self, request: RegisterHookRequest) -> Result<RegisterHookResponse, Error>;
}

// Lifecycle manager implementation with FFI interface
pub struct LifecycleManagerFFI {
    // Implementation details
}

impl LifecycleManager for LifecycleManagerFFI {
    // Implementation of the LifecycleManager trait using FFI
    // ...
}
```

### 3.2 Python API

```python
from enum import Enum
from typing import Dict, List, Optional, Union
from datetime import datetime

# Lifecycle state enum
class LifecycleState(Enum):
    UNSPECIFIED = 0
    INITIALIZED = 1
    ACTIVE = 2
    PAUSED = 3
    SUSPENDED = 4
    SHUTTING_DOWN = 5
    TERMINATED = 6
    MAINTENANCE = 7
    ERROR = 8
    UPGRADING = 9
    RECOVERING = 10

# Transition type enum
class TransitionType(Enum):
    UNSPECIFIED = 0
    NORMAL = 1
    FORCED = 2
    AUTOMATIC = 3
    ERROR_TRIGGERED = 4
    MAINTENANCE = 5

# Lifecycle event
class LifecycleEvent:
    def __init__(
        self,
        event_id: str,
        agent_id: str,
        previous_state: LifecycleState,
        new_state: LifecycleState,
        transition_type: TransitionType,
        timestamp: datetime,
        initiated_by: str,
        reason: str,
        metadata: Dict[str, str] = None
    ):
        self.event_id = event_id
        self.agent_id = agent_id
        self.previous_state = previous_state
        self.new_state = new_state
        self.transition_type = transition_type
        self.timestamp = timestamp
        self.initiated_by = initiated_by
        self.reason = reason
        self.metadata = metadata or {}

# Error information
class ErrorInfo:
    def __init__(
        self,
        code: int,
        message: str,
        timestamp: datetime,
        is_recoverable: bool,
        recovery_actions: List[str] = None
    ):
        self.code = code
        self.message = message
        self.timestamp = timestamp
        self.is_recoverable = is_recoverable
        self.recovery_actions = recovery_actions or []

# Lifecycle manager client
class LifecycleManager:
    def get_state(self, agent_id: str, include_details: bool = False) -> Dict:
        """Get the current state of an agent"""
        pass
    
    def transition_state(
        self,
        agent_id: str,
        target_state: LifecycleState,
        force: bool = False,
        reason: str = "",
        timeout_ms: int = 0,
        metadata: Dict[str, str] = None
    ) -> Dict:
        """Transition an agent to a new state"""
        pass
    
    def get_transition_history(
        self,
        agent_id: str,
        limit: int = 10,
        transition_type: Optional[TransitionType] = None,
        start_time: Optional[datetime] = None,
        end_time: Optional[datetime] = None
    ) -> List[LifecycleEvent]:
        """Get the transition history for an agent"""
        pass
    
    def watch_events(
        self,
        agent_id: Optional[str] = None,
        states: List[LifecycleState] = None,
        transition_types: List[TransitionType] = None
    ) -> 'EventStream':
        """Watch for lifecycle events"""
        pass
    
    def register_hook(
        self,
        hook_name: str,
        trigger_states: List[LifecycleState],
        trigger_transitions: List[TransitionType],
        is_blocking: bool = False,
        timeout_ms: int = 30000,
        config: Dict[str, str] = None,
        agent_ids: List[str] = None
    ) -> Dict:
        """Register a lifecycle hook"""
        pass
```

### 3.3 JavaScript/TypeScript API

```typescript
// Lifecycle state enum
export enum LifecycleState {
  Unspecified = 0,
  Initialized = 1,
  Active = 2,
  Paused = 3,
  Suspended = 4,
  ShuttingDown = 5,
  Terminated = 6,
  Maintenance = 7,
  Error = 8,
  Upgrading = 9,
  Recovering = 10
}

// Transition type enum
export enum TransitionType {
  Unspecified = 0,
  Normal = 1,
  Forced = 2,
  Automatic = 3,
  ErrorTriggered = 4,
  Maintenance = 5
}

// Lifecycle event interface
export interface LifecycleEvent {
  eventId: string;
  agentId: string;
  previousState: LifecycleState;
  newState: LifecycleState;
  transitionType: TransitionType;
  timestamp: Date;
  initiatedBy: string;
  reason: string;
  metadata?: Record<string, string>;
}

// Error information interface
export interface ErrorInfo {
  code: number;
  message: string;
  timestamp: Date;
  isRecoverable: boolean;
  recoveryActions?: string[];
}

// Get state response
export interface GetStateResponse {
  state: LifecycleState;
  timeInStateMs: number;
  previousState: LifecycleState;
  metadata?: Record<string, string>;
  isTransitioning: boolean;
  lastTransition: Date;
  errorInfo?: ErrorInfo;
}

// Transition request
export interface TransitionRequest {
  agentId: string;
  targetState: LifecycleState;
  force?: boolean;
  reason?: string;
  timeoutMs?: number;
  metadata?: Record<string, string>;
}

// Transition response
export interface TransitionResponse {
  success: boolean;
  previousState: LifecycleState;
  currentState: LifecycleState;
  event?: LifecycleEvent;
  errorMessage?: string;
}

// Lifecycle manager client
export class LifecycleManager {
  /**
   * Get the current state of an agent
   */
  async getState(agentId: string, includeDetails: boolean = false): Promise<GetStateResponse> {
    // Implementation
    return null as any;
  }
  
  /**
   * Transition an agent to a new state
   */
  async transitionState(request: TransitionRequest): Promise<TransitionResponse> {
    // Implementation
    return null as any;
  }
  
  /**
   * Get the transition history for an agent
   */
  async getTransitionHistory(
    agentId: string,
    limit: number = 10,
    transitionType?: TransitionType,
    startTime?: Date,
    endTime?: Date
  ): Promise<LifecycleEvent[]> {
    // Implementation
    return [];
  }
  
  /**
   * Watch for lifecycle events
   */
  watchEvents(
    agentId?: string,
    states?: LifecycleState[],
    transitionTypes?: TransitionType[]
  ): AsyncIterableIterator<LifecycleEvent> {
    // Implementation
    return null as any;
  }
  
  /**
   * Register a lifecycle hook
   */
  async registerHook(
    hookName: string,
    triggerStates: LifecycleState[],
    triggerTransitions: TransitionType[],
    isBlocking: boolean = false,
    timeoutMs: number = 30000,
    config?: Record<string, string>,
    agentIds?: string[]
  ): Promise<{ success: boolean; hookId: string; errorMessage?: string }> {
    // Implementation
    return null as any;
  }
}
```

## 4. Implementation Details

### 4.1 State Transition Rules

The lifecycle management system enforces a set of transition rules:

| Current State | Valid Next States | 
|---------------|-------------------|
| INITIALIZED   | ACTIVE, ERROR, TERMINATED |
| ACTIVE        | PAUSED, SUSPENDED, SHUTTING_DOWN, ERROR, MAINTENANCE |
| PAUSED        | ACTIVE, SUSPENDED, SHUTTING_DOWN, ERROR |
| SUSPENDED     | RECOVERING, TERMINATED, ERROR |
| SHUTTING_DOWN | TERMINATED, ERROR |
| TERMINATED    | None |
| MAINTENANCE   | ACTIVE, ERROR, SHUTTING_DOWN |
| ERROR         | RECOVERING, TERMINATED |
| UPGRADING     | ACTIVE, ERROR |
| RECOVERING    | ACTIVE, ERROR, TERMINATED |

### 4.2 Event Handling

Lifecycle events follow this processing flow:

1. **Event Generation**: A state transition generates an event
2. **Pre-Transition Hooks**: Any registered pre-transition hooks are executed
3. **State Change**: The agent's state is updated
4. **Post-Transition Hooks**: Any registered post-transition hooks are executed
5. **Event Notification**: The event is published to all watchers
6. **Event Storage**: The event is stored in the transition history

### 4.3 Error Handling

Error handling in the lifecycle management system includes:

1. **State Transition Errors**: Errors during state transitions
2. **Hook Execution Errors**: Errors in pre/post transition hooks
3. **Communication Errors**: Errors in event notifications
4. **Recovery Mechanism**: Automated recovery from recoverable errors

## 5. Usage Examples

### 5.1 Rust Example

```rust
use hms_agent::lifecycle::{LifecycleManager, LifecycleState, TransitionRequest};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create lifecycle manager
    let manager = LifecycleManagerFFI::new();
    
    // Get agent state
    let state_response = manager.get_state("agent-001", true)?;
    println!("Current state: {:?}", state_response.state);
    
    // Transition agent to active state
    let request = TransitionRequest {
        agent_id: "agent-001".to_string(),
        target_state: LifecycleState::Active,
        force: false,
        reason: "Starting agent for task processing".to_string(),
        timeout_ms: 5000,
        metadata: HashMap::new(),
    };
    
    let response = manager.transition_state(request)?;
    if response.success {
        println!("Transitioned from {:?} to {:?}", 
            response.previous_state, response.current_state);
    } else {
        println!("Transition failed: {}", response.error_message.unwrap_or_default());
    }
    
    Ok(())
}
```

### 5.2 Python Example

```python
from hms_agent.lifecycle import LifecycleManager, LifecycleState

# Create lifecycle manager
manager = LifecycleManager()

# Get agent state
state_response = manager.get_state("agent-001", include_details=True)
print(f"Current state: {state_response['state']}")

# Transition agent to active state
response = manager.transition_state(
    agent_id="agent-001",
    target_state=LifecycleState.ACTIVE,
    reason="Starting agent for task processing",
    timeout_ms=5000
)

if response["success"]:
    print(f"Transitioned from {response['previous_state']} to {response['current_state']}")
else:
    print(f"Transition failed: {response.get('error_message', '')}")

# Watch for lifecycle events
for event in manager.watch_events(
    agent_id="agent-001",
    states=[LifecycleState.ERROR, LifecycleState.TERMINATED]
):
    print(f"Event: {event.new_state} - {event.reason}")
```

### 5.3 JavaScript/TypeScript Example

```typescript
import { LifecycleManager, LifecycleState } from 'hms-agent-lifecycle';

async function manageAgentLifecycle() {
  // Create lifecycle manager
  const manager = new LifecycleManager();
  
  try {
    // Get agent state
    const stateResponse = await manager.getState("agent-001", true);
    console.log(`Current state: ${LifecycleState[stateResponse.state]}`);
    
    // Transition agent to active state
    const response = await manager.transitionState({
      agentId: "agent-001",
      targetState: LifecycleState.Active,
      reason: "Starting agent for task processing",
      timeoutMs: 5000
    });
    
    if (response.success) {
      console.log(`Transitioned from ${LifecycleState[response.previousState]} to ${LifecycleState[response.currentState]}`);
    } else {
      console.log(`Transition failed: ${response.errorMessage}`);
    }
    
    // Watch for lifecycle events
    const eventStream = manager.watchEvents(
      "agent-001",
      [LifecycleState.Error, LifecycleState.Terminated]
    );
    
    for await (const event of eventStream) {
      console.log(`Event: ${LifecycleState[event.newState]} - ${event.reason}`);
    }
  } catch (error) {
    console.error("Error managing agent lifecycle:", error);
  }
}

manageAgentLifecycle();
```

## 6. Integration with System-Wide FFI

The Lifecycle Management FFI bindings integrate with the system-wide FFI strategy through:

1. **Service Registration**: The LifecycleManager service is registered with the ServiceRegistry
2. **Schema Definition**: All types are defined in Protocol Buffer schemas
3. **Multi-Format Serialization**: Support for Protocol Buffers, CBOR, and JSON
4. **Transport Independence**: Works with all supported transports
5. **Error Handling**: Follows the standard error handling approach

## 7. Implementation Plan

| Task | Description | Estimated Duration |
|------|-------------|-------------------|
| Protocol Buffer Definition | Define all lifecycle management messages and services | 1 day |
| State Transition Logic | Implement the state machine and transition rules | 2 days |
| FFI Interface Implementation | Create the FFI interface layer | 2 days |
| Rust Implementation | Create the Rust implementation | 1 day |
| Python Bindings | Create Python bindings | 1 day |
| JavaScript/TypeScript Bindings | Create WebAssembly bindings | 1 day |
| Testing | Comprehensive testing across languages | 2 days |

Total: 10 days

## 8. Conclusion

The Lifecycle Management FFI bindings provide a comprehensive framework for managing agent states across language boundaries. By implementing this specification, we'll enable consistent agent lifecycle management throughout the HMS ecosystem, regardless of which language components are implemented in.